%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  qdd = call_direct_dynamics(input)%  Auxiliar function for the simulink model SIMULATE_ROBOT_AND_CONTROLLER_2DOF.%  Rearranges the inputs coming from the simulink model and calls the%  function accel.%  As a result the instantaneous acceleration at each joint is returned.%%  See also ACCEL.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Copyright (C) 2012, by Arturo Gil Aparicio%% This file is part of ARTE (A Robotics Toolbox for Education).% % ARTE is free software: you can redistribute it and/or modify% it under the terms of the GNU Lesser General Public License as published by% the Free Software Foundation, either version 3 of the License, or% (at your option) any later version.% % ARTE is distributed in the hope that it will be useful,% but WITHOUT ANY WARRANTY; without even the implied warranty of% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the% GNU Lesser General Public License for more details.% % You should have received a copy of the GNU Lesser General Public License% along with ARTE.  If not, see <http://www.gnu.org/licenses/>.function qdd = call_direct_dynamics2DOF_fast(input) global robot tau = input(1:2);   % Input torque at each joint q   = input(3:4);	   % Joint positions qd  = input(5:6);	   % Joint speeds time = input(7); %reset results vector if time == 0    robot.q_vector = []; end robot.q_vector = [robot.q_vector q];  a = eval(robot.DH.a); a1 = a(1); a2 = a(2);  gc = 9.81; % if positive, gravity points in the negative direction of the vertical Y axis  m1 = robot.dynamics.masses(1); m2 = robot.dynamics.masses(2);   %M is a 2x2 manipulator inertia matrix M = [(m1*(1/3) + m2)*a1^2 + m2*a1*a2*cos(q(2)) + (1/3)*m2*a2^2 ...        (1/2)*m2*a1*a2*cos(q(2))+(1/3)*m2*a2^2 ;       (1/2)*m2*a1*a2*cos(q(2))+(1/3)*m2*a2^2  (1/3)*m2*a2^2];  V=[-m2*a1*a2*sin(q(2))*(qd(1)*qd(2)+(1/2)*qd(2)^2);     (1/2)*m2*a1*a2*sin(q(2))*qd(1)^2];  G=[gc*(((1/2)*m1+m2)*a1*cos(q(1)) + (1/2)*m2*a2*cos(q(1)+q(2)));     (1/2)*m2*gc*a2*cos(q(1)+q(2))];  qdd=M\(tau - V - G);