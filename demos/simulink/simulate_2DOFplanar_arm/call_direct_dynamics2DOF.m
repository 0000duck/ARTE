%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  qdd = call_direct_dynamics(input)%  Auxiliar function for the simulink model SIMULATE_ROBOT_AND_CONTROLLER_2DOF.%  Rearranges the inputs coming from the simulink model and calls the%  function accel.%  As a result the instantaneous acceleration at each joint is returned.%%  See also ACCEL.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Copyright (C) 2012, by Arturo Gil Aparicio%% This file is part of ARTE (A Robotics Toolbox for Education).% % ARTE is free software: you can redistribute it and/or modify% it under the terms of the GNU Lesser General Public License as published by% the Free Software Foundation, either version 3 of the License, or% (at your option) any later version.% % ARTE is distributed in the hope that it will be useful,% but WITHOUT ANY WARRANTY; without even the implied warranty of% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the% GNU Lesser General Public License for more details.% % You should have received a copy of the GNU Lesser General Public License% along with ARTE.  If not, see <http://www.gnu.org/licenses/>.function qdd = call_direct_dynamics2DOF(input)global robot% % %set friction to zero% %robot.friction = 0;% tau = input(1:2);   % Input torque at each jointq   = input(3:4);	   % Joint positionsqd  = input(5:6);	   % Joint speeds% % % % Compute acceleration% qdd = accel(robot, q, qd, torque);ç%fprintf('\nComputing direct dynamics for the %s robot', robot.name);a = eval(robot.DH.a);a1=a(1);a2=a(2);gc=9.81;m1=robot.dynamics.masses(1);m2=robot.dynamics.masses(2);%M is a 2x2 manipulator inertia matrixM = [(m1*(1/3) + m2)*a1^2 + m2*a1*a2*cos(q(2)) + (1/3)*m2*a2^2 ...       (1/2)*m2*a1*a2*cos(q(2))+(1/3)*m2*a2^2 ;      (1/2)*m2*a1*a2*cos(q(2))+(1/3)*m2*a2^2  (1/3)*m2*a2^2];V=[-m2*a1*a2*sin(q(2))*(qd(1)*qd(2)+(1/2)*qd(2)^2);    (1/2)*m2*a1*a2*sin(q(2))*qd(1)^2];G=[gc*(((1/2)*m1+m2)*a1*cos(q(1)) + (1/2)*m2*a2*cos(q(1)+q(2)));    (1/2)*m2*gc*a2*cos(q(1)+q(2))];  % express it as a general dynamic function% M*qdd + V + G = Q, where Q is a vector of generalized forces or moments%tau = M*qdd'+ V + G;%qdd=inv(M)*(tau- V - G);qdd=M\(tau- V - G);